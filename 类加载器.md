[toc]

# 深入了解java类的加载过程

## java语言的动态性

为什么说java语言具备动态性，是因为java并不像c/c++那般直接编译链接成为机器码去执行，而是先翻译成字节码在JVM虚拟机中去执行，而这一过程并不是一次性加载所有的class文件，而是按需加载，并且对于类本身也可以做到动态初始化，且动态进行垃圾回收，自动化管理了类。

## 什么是类加载器

类加载器是java语言与jvm(c语言+汇编)的一个沟通桥梁，因此了解java的底层由jvm实现，上层由类加载器提供翻译，而内部的类加载器是按路径加载的，大致可以分以下3类，此外开发人员可以自定义类加载器。

> 引导类加载器（bootstrap class loader）：c/c++

它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。主要负责jdk_home/lib目录下的核心api 或 -Xbootclasspath 选项指定的jar包装入工作（其中的jdk_home是指配置jdk环境变量是java_home的配置路径，一般是jdk/jre所在目录）。

> 扩展类加载器（extensions class loader）：派生于classLoader类

它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录，扩展类加载器在此目录里面查找并加载 Java 类，主要负责jdk_home/lib/ext目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作。

> 系统类加载器（system class loader）：派生于classLoader类 继承扩展类加载器

它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ***ClassLoader.getSystemClassLoader()***来获取它。主要负责CLASSPATH/-Djava.class.path所指的目录下的类与jar包装入工作.

> 自定义类加载器 

### 双亲委派机制

如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。

需要加载的类 -> 自定义类加载器 -> 系统类加载器 -> 扩展类加载器 -> 引导类加载器 -> 扩展类加载器 -> 系统类加载器

案例1: 当需要加载的类是核心库的类时，该类一定需要bootstrap加载器去加载，那么系统类加载器会率先在自己缓存中查找是否已经加载过该类，没有则委派扩展类加载器去加载**parent.loadClass(name，false)**，依旧现在缓存中查找，没有则继续调用接口获取父类加载器，得到为null，则直接**findBootstrapClassOrNull(name)**获取引导类加载器去加载，最终加载成功。

案例2: 如果加载的类时类路径下的应用类，则已经到引导类加载器也加载不了时，会重新回到当前的应用类加载器进行加载。

+ 优点
  - 避免类的重复加载，父类已经加载过，子类无需加载
  - 确保一个类的全局唯一性，保护程序安全，防止核心API被随意篡改，使用的核心类始终是加载的核心class
+ 缺点
  - 父类加载器无法，访问\加载\获取，子类加载器才能加载的类
  - JNDI服务问题，SPI的实现问题 （典型例子 JDBC服务)

### 类加载器的获取方式

方式一:获取当前类的classLoader
clazz.getclassLoader ()

方式二:获取系统的classLoader
classLoader.getSystemClassLoader ()

方式三:获取当前线程上下文的ClassLoader
Thread.currentThread () .getContextClassLoader () 打破双亲委派机制 系统内部的类依旧可以访问应用类

方式四:获取调用者的classLoader
DriverManager.getCallerclassLoader () 类加载的方式

## 类的加载原理

类的加载原理则是类加载器的工作原理，而目前java中提供了如下三种加载类的方式:

- new对象 采用调用者的类加载器

- Class.forName 可以指定类加载器
- ClassLoader.getSystemClassLoader().loadClass 系统类加载器

### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流（一般会由类加载器实现）；

2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中（对于HotSpot虚拟就而言就是方法区）生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

### 链接

验证 -> 准备 -> 解析

#### 验证

1. 格式验证：验证是否符合class文件规范；
2. 语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）
3. 操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）；

#### 准备

为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作 范围内）被final修饰的static变量（常量），会直接赋值；

#### 解析

将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。解析需要静态绑定的内容。 // 所有不会被重写的方法和域都会被静态绑定

### 初始化

因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值。

方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。

> 注意：static代码块只有jvm能够调用如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。

### 实例化

1. 在堆区分配对象需要的内存分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量。

2. 对所有实例变量赋默认值，将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值。
3. 执行实例初始化代码初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。
4. 如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给



